定长编码: Ascii码，全部都是统一长度;
变长编码: 根据调用次数进行编码,此处出现越多,编码越短,最终实现总长度最短;
    --缺点: 同义性
    --实际应用: 赫夫曼编码【前缀编码,克服同义性】

赫夫曼编码分析:


传输的字符串
-1-  i like like like java do you like a java
-2-  d:1 y:1 u:1 j:2 v:2 o:2 i:4 e:4 i:5 a:5 //统计各个字符对应的个数
-3-  按照上面字符出现的次数构建一颗赫夫曼树,次数作为权值
步骤:
1.从小到大进行排序,将每一个数据,每个数据都是一个节点,每个节点可以看成是一颗最简单的二叉树;
2.取出根节点权值最小的两颗二叉树;
3.组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和;
4.再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理
就得到一颗赫夫曼树

-4-  根据赫夫曼树,给各个字符规定编码(前缀编码),向左的路径为0,向右的路径为1,编码如下
o:1000  u:10010  d:100110  y:100111  i:101
a:110  k:1100  e:1111  j:0000  v:0001
i:001  :01

-5- 按照上面的赫夫曼编码,我们的'i like like like java do you like a java'字符串对应的编码为(注意这里我们使用的无损压缩)
1010100110......
通过赫夫曼编码处理,长度为133
最终这段话的长度是:133  【ascii编码的长度为359】
压缩了(359-133)/359 = 62.9%

此编码满足前缀编码,既字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性。
因为他们都是叶子结点,所有不会出现二义性;只要符合字符要求,便可直接转义;

【注意】
	这个赫夫曼根据排序方法的不同，也可能不太一样,这样对应的赫夫曼编码也不完全一样，但是wpl是一样的，都是最小的，
最后生成的赫夫曼编码的长度是一样的；比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个。则生成的二叉树为：
